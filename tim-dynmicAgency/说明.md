##动态代理模式

###背景
动态代理模式在很多地方都有应用，想Spring的AOP，远程过程调用RPC，等地方都有用到，他们都是使用的动态代理[AOP]：`实现代理方式默认的代理器[接口]，在拦截器中使用各自的代理类去生成[反射]方法，去生产一个本地的代理类，通过动态加载代理来实现方法的调用，以及回调代理器中默认的实现方法`，在某个类中去实现个性化业务的入侵。

###分类
现在有两种代理模式：JDK动态代理、CgLib动态代理


### 详解
####JDK动态代理
这里涉及两个非常关键的两个对象：InvocationHandler、Proxy，他们是在处理动态代理中非常重要的两个对象，下面对他们进行说明：  
InvocationHandler：我们称之为调用处理器，这个类是JDK为我们提供的动态代理功能中，回调具体处理的地方。也是我们创建代理类实例时，需要传递的参数。
	在此过程中，我们需要创建一个我们自己的MyInvocationHandler implements InvocationHandler，然后覆盖实现它的固有方法Invoke(),在里面进行方法的调用，调用方式类似反射对象方法对象的调用：Method.invoke(realObject, args);这个方法在代理类，处理被代理接口的全部(部分)方法时，将会回到我们这里执行这个invoke();方法。  
	这里需要主要的是，我们在调用某个代理对象时，拿到的看似是接口的引用，但是打印该对象名称时，将会是：$Proxy0 这是因为动态代理是在内存中，动态生成的，它属于一个动态/实时/运行时的属性，动态生成的对象命名是:$开头，对应Proxy对象，附加标号0  
Proxy：